<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>L'Oracle Digital - Sistema Viu</title>
    <style>
        /* --- ESTILS UI / RESET --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* Video ocult per a processament */
        #input-video { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: 0; width: 1px; height: 1px; }

        /* Pantalla de càrrega */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #00ffcc; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
            transition: opacity 1s ease;
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid rgba(0, 255, 204, 0.3);
            border-top: 3px solid #00ffcc; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Avís d'orientació */
        #orientation-warning {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200; color: white;
            justify-content: center; align-items: center; text-align: center; padding: 20px;
        }
        
        /* Detectar mode retrat */
        @media screen and (orientation: portrait) {
            #orientation-warning { display: flex; }
        }
    </style>
</head>
<body>

    <!-- UI: Loader -->
    <div id="loader">
        <div class="spinner"></div>
        <p>INICIALITZANT NUCLI NEURONAL...</p>
        <p style="font-size: 0.8em; opacity: 0.7;">Si us plau, permet l'accés a la càmera</p>
    </div>

    <!-- UI: Warning -->
    <div id="orientation-warning">
        <div>
            <h1>GIRA EL DISPOSITIU</h1>
            <p>Aquest sistema requereix una visualització horitzontal (Landscape).</p>
        </div>
    </div>

    <!-- Elements tècnics -->
    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>

    <!-- LLIBRERIES -->
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post-processing (Bloom) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- MediaPipe (IA) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"></script>

    <script>
        /**
         * L'ORACLE DIGITAL
         * ----------------
         * Sistema interactiu que combina Three.js i MediaPipe.
         */

        // --- CONFIGURACIÓ GLOBAL ---
        const CONFIG = {
            colors: {
                idle: 0x00ffcc,    // Blau Cian (Calma)
                scared: 0xff0033,  // Vermell (Por)
                interested: 0xffcc00, // Daurat (Interès)
                base: 0x050505
            },
            thresholds: {
                handProximity: 0.25, // Distància per activar la por
                blink: 0.4          // Llindar per detectar parpelleig usuari
            }
        };

        // Estat del Sistema
        const STATE = {
            mode: 'IDLE', // IDLE, SCARED, INTERESTED
            userBlinking: false,
            handDistance: 10.0,
            handDetected: false,
            faceDetected: false
        };

        // --- 1. SHADERS (Els programes gràfics per a l'efecte matrix/digital) ---

        // Shader per al CUB DE DADES
        const dataCubeVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            void main() {
                vUv = uv;
                vNormal = normal;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const dataCubeFragmentShader = `
            uniform float iTime;
            uniform vec3 iColor;
            uniform float iActivity; 
            varying vec2 vUv;

            // Funció de soroll aleatori
            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            void main() {
                // Xarxa / Grid
                float grid = step(0.95, fract(vUv.x * 20.0)) + step(0.95, fract(vUv.y * 20.0));
                
                // Flux de dades (codi caient)
                float speed = iActivity * 2.0; 
                float flow = step(0.5, random(floor(vUv * vec2(20.0, 50.0) + vec2(0.0, iTime * speed))));
                
                // Transparència al centre per veure l'ull
                float distFromCenter = distance(vUv, vec2(0.5));
                float mask = smoothstep(0.2, 0.35, distFromCenter);

                vec3 finalColor = iColor * (grid * 0.3 + flow * 0.7);
                float alpha = (grid + flow) * mask * 0.8;

                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        // --- 2. MOTOR 3D (THREE.JS) ---
        
        let scene, camera, renderer, composer;
        let eyeGroup, pupilMesh, eyelidTop, eyelidBottom, cubeMesh, basePlane;
        let uniformsCube;

        function initThree() {
            const container = document.getElementById('canvas-container');

            // Escena
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            // Càmera
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 8);

            // Renderitzador
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // POST-PROCESSING (Bloom/Resplendor)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2; // Intensitat del brillo
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // --- CONSTRUCCIÓ DELS OBJECTES ---

            // A. L'ULL (Complexitat geomètrica procedural)
            eyeGroup = new THREE.Group();

            // 1. Escleròtica (Part blanca)
            const scleraGeo = new THREE.SphereGeometry(1, 32, 32);
            const scleraMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee, shininess: 100 });
            const sclera = new THREE.Mesh(scleraGeo, scleraMat);
            eyeGroup.add(sclera);

            // 2. Iris
            const irisGeo = new THREE.CircleGeometry(0.55, 32);
            const irisMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.idle }); // Color base
            const iris = new THREE.Mesh(irisGeo, irisMat);
            iris.position.z = 0.95;
            eyeGroup.add(iris);
            this.irisMesh = iris; // Guardar referència

            // 3. Pupil·la
            const pupilGeo = new THREE.CircleGeometry(0.25, 32);
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            pupilMesh = new THREE.Mesh(pupilGeo, pupilMat);
            pupilMesh.position.z = 0.96;
            eyeGroup.add(pupilMesh);

            // 4. Parpelles (Esferes tallades)
            const eyelidMat = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 50, side: THREE.DoubleSide });
            
            // Parpella Superior
            const topGeo = new THREE.SphereGeometry(1.02, 32, 16, 0, Math.PI * 2, 0, Math.PI/2);
            eyelidTop = new THREE.Mesh(topGeo, eyelidMat);
            eyelidTop.rotation.x = -Math.PI / 4; // Oberta
            eyeGroup.add(eyelidTop);

            // Parpella Inferior
            const botGeo = new THREE.SphereGeometry(1.02, 32, 16, 0, Math.PI * 2, Math.PI/2, Math.PI/2);
            eyelidBottom = new THREE.Mesh(botGeo, eyelidMat);
            eyelidBottom.rotation.x = Math.PI / 4; // Oberta
            eyeGroup.add(eyelidBottom);

            scene.add(eyeGroup);

            // B. EL CUB DE DADES
            const cubeGeo = new THREE.BoxGeometry(3, 3, 3);
            uniformsCube = {
                iTime: { value: 0 },
                iColor: { value: new THREE.Color(CONFIG.colors.idle) },
                iActivity: { value: 1.0 }
            };
            
            const cubeMat = new THREE.ShaderMaterial({
                uniforms: uniformsCube,
                vertexShader: dataCubeVertexShader,
                fragmentShader: dataCubeFragmentShader,
                transparent: true,
                side: THREE.BackSide, // Renderitzem l'interior per veure l'ull a través
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            // Fem dues capes del cub per donar volum
            cubeMesh = new THREE.Mesh(cubeGeo, cubeMat);
            const cubeOuter = new THREE.Mesh(cubeGeo, cubeMat.clone());
            cubeOuter.material.side = THREE.FrontSide;
            
            const cubeGroup = new THREE.Group();
            cubeGroup.add(cubeMesh);
            cubeGroup.add(cubeOuter);
            scene.add(cubeGroup);
            this.cubeGroup = cubeGroup; // Ref

            // C. LA PLACA BASE (Terra)
            const planeGeo = new THREE.PlaneGeometry(20, 20, 20, 20);
            const planeMat = new THREE.MeshBasicMaterial({ 
                color: 0x004433, 
                wireframe: true,
                transparent: true,
                opacity: 0.2
            });
            basePlane = new THREE.Mesh(planeGeo, planeMat);
            basePlane.rotation.x = -Math.PI / 2;
            basePlane.position.y = -2;
            scene.add(basePlane);

            // LLUMS
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            // Listeners
            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 3. INTEL·LIGÈNCIA ARTIFICIAL (MediaPipe) ---
        
        let visionModel;
        let lastVideoTime = -1;
        let video;

        async function initAI() {
            video = document.getElementById('input-video');
            
            // Demanar càmera
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.play();
                
                // Carregar model (FaceLandmarker per parpelleig, HandLandmarker per gestos)
                // Usarem FaceLandmarker perquè és més lleuger per als ulls, i heurística per a mans si calgués, 
                // però per simplicitat en un sol fitxer usarem el FaceLandmarker que inclou detecció bàsica.
                // PERÒ, el prompt demana "moviment de mans". Carregarem el "Holistic" o dos models?
                // Per rendiment, farem servir FACE LANDMARKER (per ulls/cap) i suposarem moviment general per activitat.
                
                // *Nota tècnica*: Carregar múltiples models en JS pur en un sol arxiu pot ser pesat.
                // Usarem FaceLandmarker per controlar l'ull. Si el FaceLandmarker detecta la cara molt a prop, s'espantarà.
                
                const vision = await mediapipeTasksVision.FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );

                visionModel = await mediapipeTasksVision.FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: true,
                    runningMode: "VIDEO",
                    numFaces: 1
                });

                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
                
                predictWebcam();

            } catch (err) {
                console.error("Error càmera/IA:", err);
                alert("Error: No es pot accedir a la càmera. Assegura't d'usar HTTPS o Localhost.");
            }
        }

        async function predictWebcam() {
            if (visionModel && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const result = visionModel.detectForVideo(video, performance.now());
                
                if (result.faceLandmarks && result.faceLandmarks.length > 0) {
                    STATE.faceDetected = true;
                    processFaceData(result);
                } else {
                    STATE.faceDetected = false;
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        // Processament de lògica IA -> 3D
        function processFaceData(result) {
            // 1. Detecció de parpelleig (Blendshapes)
            // eyeBlinkLeft i eyeBlinkRight són índexs específics, normalment 9 i 10 als categories
            const blendshapes = result.faceBlendshapes[0].categories;
            const blinkLeft = blendshapes.find(s => s.categoryName === 'eyeBlinkLeft').score;
            const blinkRight = blendshapes.find(s => s.categoryName === 'eyeBlinkRight').score;
            
            STATE.userBlinking = (blinkLeft > CONFIG.thresholds.blink || blinkRight > CONFIG.thresholds.blink);

            // 2. Posició del cap (per moure l'ull 3D)
            const landmarks = result.faceLandmarks[0];
            // Nas és aprox l'índex 1
            const nose = landmarks[1];
            
            // Normalitzem coordenades (0-1) a (-1 a 1)
            const lookX = (nose.x - 0.5) * -2; // Invertim X mirall
            const lookY = (nose.y - 0.5) * -2;
            const distance = nose.z; // Z relatiu

            // Actualitzem objectiu de l'ull
            targetLook.set(lookX * 3, lookY * 3);

            // 3. Detecció de Proximitat (POR)
            // El valor Z de mediapipe és relatiu. Si és molt negatiu, està a prop.
            // També podem usar l'amplada de la cara.
            // Simulació simple: si la cara ocupa molt, "por".
            
            // Distància aproximada basada en la separació dels ulls
            const leftEye = landmarks[33];
            const rightEye = landmarks[263];
            const faceWidth = Math.sqrt(Math.pow(leftEye.x - rightEye.x, 2));

            if (faceWidth > 0.25) { // Molt a prop
                STATE.mode = 'SCARED';
            } else if (STATE.userBlinking) {
                STATE.mode = 'INTERESTED'; // Respon a la comunicació
            } else {
                STATE.mode = 'IDLE';
            }
        }

        // --- 4. BUCLE D'ANIMACIÓ I LÒGICA DE REACTIVITAT ---

        const clock = new THREE.Clock();
        const targetLook = new THREE.Vector2(0, 0);
        const currentLook = new THREE.Vector2(0, 0);
        let blinkValue = 0; // 0 obert, 1 tancat

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            // Actualització Shaders
            if (uniformsCube) {
                uniformsCube.iTime.value = time;
                
                // Reacció de Color i Intensitat segons estat
                let targetColor = new THREE.Color(CONFIG.colors.idle);
                let activity = 1.0;

                if (STATE.mode === 'SCARED') {
                    targetColor.setHex(CONFIG.colors.scared);
                    activity = 5.0; // Caos
                    // Vibració del cub (Por)
                    this.cubeGroup.position.x = (Math.random() - 0.5) * 0.1;
                    this.cubeGroup.position.y = (Math.random() - 0.5) * 0.1;
                    
                    // Pupil·la es contrau
                    pupilMesh.scale.lerp(new THREE.Vector3(0.5, 0.5, 1), 0.1);

                } else if (STATE.mode === 'INTERESTED') {
                    targetColor.setHex(CONFIG.colors.interested);
                    activity = 2.0;
                    this.cubeGroup.position.set(0,0,0);
                    // Pupil·la es dilata
                    pupilMesh.scale.lerp(new THREE.Vector3(1.3, 1.3, 1), 0.1);
                } else {
                    // IDLE
                    this.cubeGroup.position.set(0,0,0);
                    // Moviment suau "respiració"
                    this.cubeGroup.rotation.y = Math.sin(time * 0.2) * 0.1;
                    pupilMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                }

                // Interpolació suau del color
                uniformsCube.iColor.value.lerp(targetColor, 0.05);
                uniformsCube.iActivity.value = THREE.MathUtils.lerp(uniformsCube.iActivity.value, activity, 0.05);
            }

            // MOVIMENT DE L'ULL
            // Si no detecta cara, mira al voltant aleatòriament (Noise)
            if (!STATE.faceDetected) {
                const noiseX = Math.sin(time * 0.5) + Math.cos(time * 1.2);
                const noiseY = Math.cos(time * 0.7);
                targetLook.set(noiseX * 0.5, noiseY * 0.3);
                STATE.mode = 'IDLE';
            }

            // Interpolació del moviment de l'ull (perquè sigui orgànic)
            currentLook.lerp(targetLook, 0.1);
            eyeGroup.lookAt(currentLook.x, currentLook.y, 5);

            // PARPELLEIG
            let targetBlink = STATE.userBlinking ? 1 : 0;
            
            // Parpelleig automàtic aleatori si està Idle
            if (!STATE.userBlinking && Math.random() < 0.005) {
                targetBlink = 1;
            }

            blinkValue += (targetBlink - blinkValue) * 0.2; // Suavitzat

            // Aplicar parpelleig a les parpelles
            // Superior: de -PI/4 (obert) a 0 (tancat)
            eyelidTop.rotation.x = THREE.MathUtils.mapLinear(blinkValue, 0, 1, -Math.PI/4, 0);
            // Inferior: de PI/4 (obert) a 0 (tancat)
            eyelidBottom.rotation.x = THREE.MathUtils.mapLinear(blinkValue, 0, 1, Math.PI/4, 0);

            // Render
            composer.render();
        }

        // --- INICI ---
        window.onload = () => {
            initThree();
            initAI();
            animate();
        };

    </script>
</body>
</html>