<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>L'Oracle Digital - Sistema Viu</title>
    <style>
        /* --- ESTILS UI / RESET --- */
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* Video ocult per a processament */
        #input-video { position: absolute; top: 0; left: 0; opacity: 0; pointer-events: none; z-index: 0; width: 1px; height: 1px; }

        /* Pantalla de càrrega */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; color: #00ffcc; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 100;
            transition: opacity 1s ease;
            text-align: center; /* Per centrar el missatge d'error si és llarg */
            padding: 20px;
            box-sizing: border-box;
        }
        .spinner {
            width: 50px; height: 50px; border: 3px solid rgba(0, 255, 204, 0.3);
            border-top: 3px solid #00ffcc; border-radius: 50%;
            animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Avís d'orientació */
        #orientation-warning {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 200; color: white;
            justify-content: center; align-items: center; text-align: center; padding: 20px;
        }
        
        /* Detectar mode retrat */
        @media screen and (orientation: portrait) {
            #orientation-warning { display: flex; }
        }
    </style>
</head>
<body>

    <!-- UI: Loader -->
    <div id="loader">
        <div class="spinner"></div>
        <p id="loader-status">INICIALITZANT NUCLI NEURONAL...</p>
        <p style="font-size: 0.8em; opacity: 0.7;">Si us plau, permet l'accés a la càmera</p>
    </div>

    <!-- UI: Warning -->
    <div id="orientation-warning">
        <div>
            <h1>GIRA EL DISPOSITIU</h1>
            <p>Aquest sistema requereix una visualització horitzontal (Landscape).</p>
        </div>
    </div>

    <!-- Elements tècnics -->
    <video id="input-video" playsinline></video>
    <div id="canvas-container"></div>

    <!-- LLIBRERIES THREE.JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <!-- MediaPipe (IA) - Necessita type="module" -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision/vision_bundle.js"></script>

    <!-- Codi de l'aplicació - Necessita type="module" -->
    <script type="module">
        /**
         * L'ORACLE DIGITAL - Versió 2.3 (Control d'errors de Càmera Millorat)
         */

        // Recuperem l'objecte de MediaPipe.
        const mpVision = globalThis.mediapipeTasksVision || {};


        // --- CONFIGURACIÓ GLOBAL ---
        const CONFIG = {
            colors: {
                idle: 0x00ffcc,    // Blau Cian (Calma)
                scared: 0xff0033,  // Vermell (Por)
                interested: 0xffcc00, // Daurat (Interès)
                base: 0x050505
            },
            thresholds: {
                handProximity: 0.25, // Distància per activar la por
                blink: 0.4          // Llindar per detectar parpelleig usuari
            }
        };

        // Estat del Sistema
        const STATE = {
            mode: 'IDLE', // IDLE, SCARED, INTERESTED
            userBlinking: false,
            handDistance: 10.0,
            handDetected: false,
            faceDetected: false
        };

        // --- 1. SHADERS (Els programes gràfics per a l'efecte matrix/digital) ---

        const dataCubeVertexShader = `
            varying vec2 vUv;
            varying vec3 vNormal;
            void main() {
                vUv = uv;
                vNormal = normal;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const dataCubeFragmentShader = `
            uniform float iTime;
            uniform vec3 iColor;
            uniform float iActivity; 
            varying vec2 vUv;

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            void main() {
                float grid = step(0.95, fract(vUv.x * 20.0)) + step(0.95, fract(vUv.y * 20.0));
                float speed = iActivity * 2.0; 
                float flow = step(0.5, random(floor(vUv * vec2(20.0, 50.0) + vec2(0.0, iTime * speed))));
                float distFromCenter = distance(vUv, vec2(0.5));
                float mask = smoothstep(0.2, 0.35, distFromCenter);

                vec3 finalColor = iColor * (grid * 0.3 + flow * 0.7);
                float alpha = (grid + flow) * mask * 0.8;

                gl_FragColor = vec4(finalColor, alpha);
            }
        `;

        // --- 2. MOTOR 3D (THREE.JS) ---
        
        let scene, camera, renderer, composer;
        let eyeGroup, pupilMesh, eyelidTop, eyelidBottom, cubeMesh, basePlane;
        let uniformsCube;
        let irisMesh;

        function initThree() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 0, 8);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // A. L'ULL
            eyeGroup = new THREE.Group();
            const scleraGeo = new THREE.SphereGeometry(1, 32, 32);
            const scleraMat = new THREE.MeshPhongMaterial({ color: 0xeeeeee, shininess: 100 });
            eyeGroup.add(new THREE.Mesh(scleraGeo, scleraMat));

            const irisGeo = new THREE.CircleGeometry(0.55, 32);
            const irisMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.idle });
            irisMesh = new THREE.Mesh(irisGeo, irisMat);
            irisMesh.position.z = 0.95;
            eyeGroup.add(irisMesh);

            const pupilGeo = new THREE.CircleGeometry(0.25, 32);
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            pupilMesh = new THREE.Mesh(pupilGeo, pupilMat);
            pupilMesh.position.z = 0.96;
            eyeGroup.add(pupilMesh);

            const eyelidMat = new THREE.MeshPhongMaterial({ color: 0x111111, shininess: 50, side: THREE.DoubleSide });
            
            const topGeo = new THREE.SphereGeometry(1.02, 32, 16, 0, Math.PI * 2, 0, Math.PI/2);
            eyelidTop = new THREE.Mesh(topGeo, eyelidMat);
            eyelidTop.rotation.x = -Math.PI / 4;
            eyeGroup.add(eyelidTop);

            const botGeo = new THREE.SphereGeometry(1.02, 32, 16, 0, Math.PI * 2, Math.PI/2, Math.PI/2);
            eyelidBottom = new THREE.Mesh(botGeo, eyelidMat);
            eyelidBottom.rotation.x = Math.PI / 4;
            eyeGroup.add(eyelidBottom);

            scene.add(eyeGroup);

            // B. EL CUB DE DADES
            const cubeGeo = new THREE.BoxGeometry(3, 3, 3);
            uniformsCube = {
                iTime: { value: 0 },
                iColor: { value: new THREE.Color(CONFIG.colors.idle) },
                iActivity: { value: 1.0 }
            };
            
            const cubeMat = new THREE.ShaderMaterial({
                uniforms: uniformsCube,
                vertexShader: dataCubeVertexShader,
                fragmentShader: dataCubeFragmentShader,
                transparent: true,
                side: THREE.BackSide,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });
            
            cubeMesh = new THREE.Mesh(cubeGeo, cubeMat);
            const cubeOuter = new THREE.Mesh(cubeGeo, cubeMat.clone());
            cubeOuter.material.side = THREE.FrontSide;
            
            const cubeGroup = new THREE.Group();
            cubeGroup.add(cubeMesh);
            cubeGroup.add(cubeOuter);
            scene.add(cubeGroup);
            this.cubeGroup = cubeGroup;

            // C. LA PLACA BASE (Terra)
            const planeGeo = new THREE.PlaneGeometry(20, 20, 20, 20);
            const planeMat = new THREE.MeshBasicMaterial({ 
                color: 0x004433, 
                wireframe: true,
                transparent: true,
                opacity: 0.2
            });
            basePlane = new THREE.Mesh(planeGeo, planeMat);
            basePlane.rotation.x = -Math.PI / 2;
            basePlane.position.y = -2;
            scene.add(basePlane);

            // LLUMS
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffffff, 1);
            pointLight.position.set(5, 5, 5);
            scene.add(pointLight);

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- 3. INTEL·LIGÈNCIA ARTIFICIAL (MediaPipe) ---
        
        let visionModel;
        let video;

        async function initAI() {
            // Comprovació que MediaPipe s'ha carregat bé.
            if (!mpVision || !mpVision.FaceLandmarker) {
                document.getElementById('loader-status').innerHTML = "ERROR CRÍTIC: Mòduls d'IA no carregats. Recarregueu la pàgina.";
                return;
            }

            video = document.getElementById('input-video');
            const loaderStatus = document.getElementById('loader-status');

            loaderStatus.innerText = "Carregant mòduls d'Intel·ligència Artificial...";

            try {
                const vision = await mpVision.FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );

                visionModel = await mpVision.FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                        delegate: "GPU"
                    },
                    outputFaceBlendshapes: true,
                    runningMode: mpVision.RunningMode.VIDEO, 
                    numFaces: 1
                });

                loaderStatus.innerText = "Sol·licitant accés a la càmera...";
                
                // INICIALITZACIÓ DE LA CÀMERA AMB CONTROL D'ERRORS MILLORAT (v2.3)
                await navigator.mediaDevices.getUserMedia({ video: true })
                    .then((stream) => {
                        video.srcObject = stream;
                        
                        const startWebcam = () => {
                            video.play();
                            loaderStatus.innerText = "Sistema Operatiu. Mirant...";
                            document.getElementById('loader').style.opacity = '0';
                            setTimeout(() => document.getElementById('loader').style.display = 'none', 1000);
                            predictWebcam();
                        };

                        // Afegim el listener per assegurar que el vídeo estigui llest
                        video.addEventListener('loadeddata', startWebcam);

                        // Fallback: Si la càmera carrega però l'event 'loadeddata' no es dispara ràpidament (problema en certs dispositius)
                        setTimeout(() => {
                           if (video.srcObject && video.readyState >= 2 && loaderStatus.innerText === "Sol·licitant accés a la càmera...") {
                                console.warn("Forçant l'inici de la càmera, loadeddata no s'ha disparat.");
                                startWebcam();
                                video.removeEventListener('loadeddata', startWebcam); // Evitem doble inici
                           }
                        }, 4000); // Temps màxim d'espera de 4 segons

                    })
                    .catch((err) => {
                        console.error("Error al sol·licitar la càmera:", err);
                        
                        let message = "ERROR: Permís de càmera denegat o no disponible.";
                        let color = '#ff0033';
                        
                        if (err.name === 'NotAllowedError') {
                            message = "ERROR: Permís denegat. Has de donar accés a la càmera al navegador.";
                        } else if (err.name === 'NotReadableError') {
                            message = "ERROR: La càmera està ocupada. Tanca altres aplicacions que la facin servir.";
                        } else if (err.name === 'SecurityError') {
                            message = "ERROR: Es requereix una connexió segura (HTTPS).";
                        }
                        
                        loaderStatus.innerHTML = message + 
                            `<br><span style="font-size: 0.8em; opacity: 0.7;">
                            Codi d'error: ${err.name || 'Desconegut'}. Verifica la configuració de permisos del teu navegador i recarrega la pàgina.
                            </span>`;
                        
                        // Canviem l'estil per mostrar que és un error greu
                        document.getElementById('loader').style.backgroundColor = '#100';
                        document.getElementById('loader').style.color = color;
                        document.querySelector('.spinner').style.borderTop = '3px solid #ff0033';
                    });
                
            } catch (err) {
                console.error("Error de càrrega d'IA:", err);
                loaderStatus.innerHTML = `
                    ERROR CRÍTIC AL NUCLI NEURONAL.<br>
                    Codi d'error: ${err.name || 'Desconegut'}.
                `;
            }
        }

        async function predictWebcam() {
            if (visionModel && video.readyState === video.HAVE_ENOUGH_DATA) {
                const now = performance.now();
                const result = visionModel.detectForVideo(video, now);
                
                if (result.faceLandmarks && result.faceLandmarks.length > 0) {
                    STATE.faceDetected = true;
                    processFaceData(result);
                } else {
                    STATE.faceDetected = false;
                }
            }
            requestAnimationFrame(predictWebcam);
        }

        function processFaceData(result) {
            const blendshapes = result.faceBlendshapes[0].categories;
            const blinkLeft = blendshapes.find(s => s.categoryName === 'eyeBlinkLeft')?.score || 0;
            const blinkRight = blendshapes.find(s => s.categoryName === 'eyeBlinkRight')?.score || 0;
            
            STATE.userBlinking = (blinkLeft > CONFIG.thresholds.blink || blinkRight > CONFIG.thresholds.blink);

            const landmarks = result.faceLandmarks[0];
            const nose = landmarks[1];
            
            const lookX = (nose.x - 0.5) * -2;
            const lookY = (nose.y - 0.5) * -2;

            targetLook.set(lookX * 3, lookY * 3);

            const leftEye = landmarks[33];
            const rightEye = landmarks[263];
            const faceWidth = Math.sqrt(Math.pow(leftEye.x - rightEye.x, 2));

            if (faceWidth > 0.25) {
                STATE.mode = 'SCARED';
            } else if (STATE.userBlinking) {
                STATE.mode = 'INTERESTED';
            } else {
                STATE.mode = 'IDLE';
            }
        }

        // --- 4. BUCLE D'ANIMACIÓ I LÒGICA DE REACTIVITAT ---

        const clock = new THREE.Clock();
        const targetLook = new THREE.Vector2(0, 0);
        const currentLook = new THREE.Vector2(0, 0);
        let blinkValue = 0;

        function animate() {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            const time = clock.getElapsedTime();

            if (uniformsCube) {
                uniformsCube.iTime.value = time;
                
                let targetColor = new THREE.Color(CONFIG.colors.idle);
                let activity = 1.0;

                if (STATE.mode === 'SCARED') {
                    targetColor.setHex(CONFIG.colors.scared);
                    activity = 5.0;
                    this.cubeGroup.position.x = (Math.random() - 0.5) * 0.1;
                    this.cubeGroup.position.y = (Math.random() - 0.5) * 0.1;
                    pupilMesh.scale.lerp(new THREE.Vector3(0.5, 0.5, 1), 0.1);

                } else if (STATE.mode === 'INTERESTED') {
                    targetColor.setHex(CONFIG.colors.interested);
                    activity = 2.0;
                    this.cubeGroup.position.set(0,0,0);
                    pupilMesh.scale.lerp(new THREE.Vector3(1.3, 1.3, 1), 0.1);
                } else {
                    this.cubeGroup.position.set(0,0,0);
                    this.cubeGroup.rotation.y = Math.sin(time * 0.2) * 0.1;
                    pupilMesh.scale.lerp(new THREE.Vector3(1, 1, 1), 0.1);
                }

                uniformsCube.iColor.value.lerp(targetColor, 0.05);
                irisMesh.material.color.lerp(targetColor, 0.05);
                uniformsCube.iActivity.value = THREE.MathUtils.lerp(uniformsCube.iActivity.value, activity, 0.05);
            }

            if (!STATE.faceDetected) {
                const noiseX = Math.sin(time * 0.5) + Math.cos(time * 1.2);
                const noiseY = Math.cos(time * 0.7);
                targetLook.set(noiseX * 0.5, noiseY * 0.3);
                STATE.mode = 'IDLE';
            }

            currentLook.lerp(targetLook, 0.1);
            eyeGroup.lookAt(currentLook.x, currentLook.y, 5);

            let targetBlink = STATE.userBlinking ? 1 : 0;
            
            if (!STATE.userBlinking && Math.random() < 0.005) {
                targetBlink = 1;
            }

            blinkValue += (targetBlink - blinkValue) * 0.2;

            eyelidTop.rotation.x = THREE.MathUtils.mapLinear(blinkValue, 0, 1, -Math.PI/4, 0);
            eyelidBottom.rotation.x = THREE.MathUtils.mapLinear(blinkValue, 0, 1, Math.PI/4, 0);

            composer.render();
        }

        // --- INICI ---
        window.onload = () => {
            initThree();
            initAI();
            animate();
        };

    </script>
</body>
</html>
